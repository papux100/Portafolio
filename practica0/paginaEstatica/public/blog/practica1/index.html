<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/Portafolio/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=Portafolio/livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>My New Hugo Site</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Paradigmas
Practica 1
12/9/2025
Angel Rey Rodriguez(377864)
Prof. Carlos Gallegos
Reporte
introduccion:
A través de este ejercicio, se exploran conceptos clave de programación, como nombres, marcos de activación, bloques de alcance, administración de memoria, expresiones, comandos, estructuras de control de secuencia (selección, iteración y recursión), subprogramas y tipos de datos. El objetivo es desglosar el código para comprender cómo cada uno de estos elementos contribuye a la funcionalidad del sistema, destacando su organización, modularidad y manejo eficiente de recursos.">
    <meta name="generator" content="Hugo 0.149.0">
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    

    
<link rel="stylesheet" href="/Portafolio/ananke/css/main.min.css" >




    


    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/Portafolio/blog/practica1/">
    

    <meta property="og:url" content="http://localhost:1313/Portafolio/blog/practica1/">
  <meta property="og:site_name" content="My New Hugo Site">
  <meta property="og:title" content="My New Hugo Site">
  <meta property="og:description" content="Paradigmas Practica 1 12/9/2025 Angel Rey Rodriguez(377864) Prof. Carlos Gallegos Reporte introduccion: A través de este ejercicio, se exploran conceptos clave de programación, como nombres, marcos de activación, bloques de alcance, administración de memoria, expresiones, comandos, estructuras de control de secuencia (selección, iteración y recursión), subprogramas y tipos de datos. El objetivo es desglosar el código para comprender cómo cada uno de estos elementos contribuye a la funcionalidad del sistema, destacando su organización, modularidad y manejo eficiente de recursos.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blog">

  <meta itemprop="name" content="My New Hugo Site">
  <meta itemprop="description" content="Paradigmas Practica 1 12/9/2025 Angel Rey Rodriguez(377864) Prof. Carlos Gallegos Reporte introduccion: A través de este ejercicio, se exploran conceptos clave de programación, como nombres, marcos de activación, bloques de alcance, administración de memoria, expresiones, comandos, estructuras de control de secuencia (selección, iteración y recursión), subprogramas y tipos de datos. El objetivo es desglosar el código para comprender cómo cada uno de estos elementos contribuye a la funcionalidad del sistema, destacando su organización, modularidad y manejo eficiente de recursos.">
  <meta itemprop="wordCount" content="1938">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="My New Hugo Site">
  <meta name="twitter:description" content="Paradigmas Practica 1 12/9/2025 Angel Rey Rodriguez(377864) Prof. Carlos Gallegos Reporte introduccion: A través de este ejercicio, se exploran conceptos clave de programación, como nombres, marcos de activación, bloques de alcance, administración de memoria, expresiones, comandos, estructuras de control de secuencia (selección, iteración y recursión), subprogramas y tipos de datos. El objetivo es desglosar el código para comprender cómo cada uno de estos elementos contribuye a la funcionalidad del sistema, destacando su organización, modularidad y manejo eficiente de recursos.">

	
  </head><body class="ma0 avenir bg-near-white development">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l center items-center justify-between">
    <a href="/Portafolio/" class="f3 fw2 hover-white white-90 dib no-underline">
      
        My New Hugo Site
      
    </a>
    <div class="flex-l items-center">
      

      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  
  <article class="flex-l mw8 center ph3 flex-wrap justify-between">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Blogs
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1"></h1>
      
      
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><h1 id="paradigmas">Paradigmas</h1>
<h2 id="practica-1">Practica 1</h2>
<h2 id="1292025">12/9/2025</h2>
<h2 id="angel-rey-rodriguez377864">Angel Rey Rodriguez(377864)</h2>
<h2 id="prof-carlos-gallegos">Prof. Carlos Gallegos</h2>
<h2 id="reporte">Reporte</h2>
<h1 id="introduccion">introduccion:</h1>
<p>A través de este ejercicio, se exploran conceptos clave de programación, como nombres, marcos de activación, bloques de alcance, administración de memoria, expresiones, comandos, estructuras de control de secuencia (selección, iteración y recursión), subprogramas y tipos de datos. El objetivo es desglosar el código para comprender cómo cada uno de estos elementos contribuye a la funcionalidad del sistema, destacando su organización, modularidad y manejo eficiente de recursos.</p>
<h1 id="intrucciones">intrucciones</h1>
<p>El objetivo de esta práctica es identificar los elementos fundamentales de los lenguajes de programación: nombres, marcos de activación, bloques de alcance, administración de memoria, expresiones, comandos, control de secuencia como lo es; selección, iteración y recursión, subprogramas, y tipos de datos.</p>
<p>Identificar estos conceptos en la aplicación propuesta para esta práctica.</p>
<p>Entregar aquí en classroom el reporte en PDF de la práctica, generado a partir del contenido en su portafolio. No olviden añadir al reporte el enlace a su portafolio y al sitio estático, donde este reporte es la segunda entrada.</p>
<p>Repositorio de código para la práctica: <a href="https://github.com/gallegosj89/portafolio">https://github.com/gallegosj89/portafolio</a></p>
<h1 id="resultados">Resultados</h1>
<h2 id="1-nombres">1. Nombres</h2>
<p>Los nombres son identificadores utilizados para variables, funciones, estructuras, enumeraciones, etc. En el código, encontramos:</p>
<ul>
<li>
<p><strong>Variables:</strong></p>
<ul>
<li>
<p><strong>Globales:</strong> static_var (estática, segmento de datos), bss_var (BSS, no inicializada).</p>
</li>
<li>
<p><strong>Locales (stack)</strong>: library, members, bookCount, memberCount, choice (en main), new_book, current, bookFound, memberFound, etc.</p>
</li>
<li>
<p><strong>Campos de estructuras:</strong> id, title, author, publication_year, genre, quantity, next (en book_t); id, name, issued_count, issued_books, next (en member_t).</p>
</li>
</ul>
</li>
<li>
<p><strong>Funciones:</strong></p>
<ul>
<li>genreToString, addBook, findBookById, displayBooksRecursive, displayBooks, addMember, issueBook, returnBook, freeLibrary, freeMembers, saveLibraryToFile, loadLibraryFromFile, saveMembersToFile, loadMembersFromFile, displayMembers, searchMember, main.</li>
</ul>
</li>
<li>
<p><strong>Tipos definidos:</strong></p>
<ul>
<li>genre_t (enumeración).</li>
<li>book_t, member_t (estructuras).</li>
</ul>
</li>
<li>
<p><strong>Constantes:</strong></p>
<ul>
<li>Enumeradores: FICTION, NON_FICTION, SCIENCE, HISTORY, FANTASY, BIOGRAPHY, OTHER.</li>
<li>Cadenas literales: &ldquo;Error al asignar memoria&rdquo;, &ldquo;library.txt&rdquo;, etc.</li>
</ul>
</li>
<li>
<p><strong>2. Marcos de activación</strong></p>
</li>
</ul>
<p>Los marcos de activación (o registros de activación) son áreas en el stack que almacenan información sobre una llamada a función, incluyendo parámetros, variables locales y el valor de retorno. En este código:</p>
<ul>
<li>
<p><strong>Ejemplos de marcos de activación:</strong></p>
<ul>
<li>En addBook: parámetros (library, count), variables locales (new_book, genre).</li>
<li>En main: variables locales (library, members, bookCount, memberCount, choice).</li>
<li>Cada llamada a función crea un nuevo marco de activación en el stack, que se libera al retornar.</li>
</ul>
</li>
<li>
<p><strong>Comportamiento:</strong></p>
<ul>
<li>Las variables locales como new_book en addBook o current en findBookById se almacenan en el stack.</li>
<li>Los parámetros (library, count) se pasan por valor o puntero, almacenados en el marco de activación de la función.</li>
</ul>
</li>
</ul>
<h2 id="3-bloques-de-alcance">3. Bloques de alcance</h2>
<p>Los bloques de alcance definen la visibilidad y vida útil de los nombres. En el código:</p>
<ul>
<li>
<p><strong>Alcance global:</strong></p>
<ul>
<li>Variables: static_var (estática, alcance de archivo),  bss_var (global, no inicializada).</li>
<li>Definiciones: genre_t, book_t, member_t.</li>
</ul>
</li>
<li>
<p><strong>Alcance de función:</strong></p>
<ul>
<li>Variables locales en funciones como new_book en addBook, current en findBookById.</li>
<li>Ejemplo: En addBook, new_book y genre solo son visibles dentro de la función.</li>
</ul>
</li>
<li>
<p><strong>Alcance de bloque:</strong></p>
<ul>
<li>Dentro de bucles o condicionales, como i en el bucle for de issueBook:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> memberFound<span style="color:#f92672">-&gt;</span>issued_count; i<span style="color:#f92672">++</span>)
</span></span></code></pre></div><ul>
<li>Aquí, i solo existe dentro del bucle.</li>
</ul>
</li>
<li>
<p><strong>Alcance estático:</strong></p>
<ul>
<li>static_var tiene alcance de archivo, pero su vida útil es durante toda la ejecución del programa.</li>
</ul>
</li>
</ul>
<h2 id="4-administración-de-memoria">4. Administración de memoria</h2>
<p>El código utiliza varios esquemas de administración de memoria:</p>
<ul>
<li>
<p><strong>Segmento de datos:</strong></p>
<ul>
<li>static_var (inicializada, estática).</li>
<li>Cadenas literales como &ldquo;Ficcion&rdquo;.</li>
</ul>
</li>
<li>
<p><strong>Segmento BSS:</strong></p>
<ul>
<li>bss_var (global no inicializada).</li>
</ul>
</li>
<li>
<p><strong>Stack:</strong></p>
<ul>
<li>Variables locales automáticas: library, members, bookCount, choice, etc.</li>
<li>Parámetros de funciones: library, count en addBook.</li>
</ul>
</li>
<li>
<p><strong>Heap:</strong></p>
<ul>
<li>
<p>Asignación dinámica con malloc y realloc:</p>
<ul>
<li>En addBook: new_book = (book_t *)malloc(sizeof(book_t)).</li>
<li>En issueBook: realloc para issued_books.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Liberación con free:</strong></p>
<ul>
<li>En freeLibrary: free(current) para cada nodo de la lista book_t.</li>
<li>En freeMembers: free(current-&gt;issued_books) y free(current).</li>
</ul>
</li>
<li>
<p>Seguimiento de memoria:</p>
<ul>
<li>Funciones como incrementHeapAllocations y incrementHeapDeallocations (definidas en memory_management.h) rastrean asignaciones y liberaciones.</li>
</ul>
</li>
<li>
<p><strong>Gestión explícita:</strong></p>
<ul>
<li>El código verifica errores de asignación (if (!new_book)).</li>
<li>Usa listas enlazadas (next) para gestionar estructuras dinámicas (book_t, member_t).</li>
</ul>
</li>
</ul>
<h2 id="5-expresiones">5. Expresiones</h2>
<p>Las expresiones son combinaciones de operandos y operadores que producen un valor. Ejemplos:</p>
<ul>
<li>
<p><strong>Aritméticas:</strong></p>
<ul>
<li>(*count)++ en addBook.
bookFound-&gt;quantity&ndash; en issueBook.</li>
</ul>
</li>
<li>
<p><strong>Lógicas:</strong></p>
<ul>
<li>if (bookFound &amp;&amp; memberFound) en issueBook.</li>
<li>while (current) en findBookById.</li>
</ul>
</li>
<li>
<p><strong>Asignación:</strong></p>
<ul>
<li>new_book-&gt;id = scanf(&quot;%d&quot;, &amp;new_book-&gt;id) (lectura).</li>
<li>new_book-&gt;next = *library en addBook.</li>
</ul>
</li>
<li>
<p><strong>Llamadas a funciones:</strong></p>
<ul>
<li>genreToString(library-&gt;genre) en displayBooksRecursive.</li>
<li>malloc(sizeof(book_t)) en addBook.</li>
</ul>
</li>
<li>
<p><strong>Comparaciones:</strong></p>
<ul>
<li>if (current-&gt;id == bookID) en findBookById.</li>
<li>strcmp(genre_str, &ldquo;Ficcion&rdquo;) == 0 en loadLibraryFromFile.</li>
</ul>
</li>
</ul>
<h2 id="6-comandos">6. Comandos</h2>
<p>Los comandos son instrucciones ejecutables en el programa. Ejemplos:</p>
<ul>
<li>
<p><strong>Asignaciones:</strong></p>
<ul>
<li>new_book-&gt;quantity = scanf(&quot;%d&quot;, &amp;new_book-&gt;quantity) en addBook.</li>
<li>memberFound-&gt;issued_books = realloc(&hellip;) en issueBook.</li>
</ul>
</li>
<li>
<p><strong>Entrada/salida:</strong></p>
<ul>
<li>printf(&ldquo;Ingresa ID del libro: &ldquo;) en addBook.</li>
<li>fscanf(file, &ldquo;%d\n&rdquo;, &amp;new_book-&gt;id) en loadLibraryFromFile.</li>
</ul>
</li>
<li>
<p><strong>Control de flujo:</strong></p>
<ul>
<li>if, switch, while, for (ver control de secuencia).</li>
<li>return NULL en findBookById.</li>
</ul>
</li>
<li>
<p><strong>Llamadas a funciones:</strong></p>
<ul>
<li>incrementHeapAllocations(new_book, sizeof(book_t)) en addBook.</li>
<li>fclose(file) en saveLibraryToFile.</li>
</ul>
</li>
</ul>
<p>El control de secuencia incluye selección, iteración y recursión:</p>
<ul>
<li><strong>Selección:</strong></li>
</ul>
<p>if-else:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>new_book) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Error al asignar memoria...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>En addBook, verifica si la asignación de memoria falló.</p>
<ul>
<li><strong>switch:</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">switch</span> (genre) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> FICTION: <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Ficcion&#34;</span>;
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>En genreToString, selecciona una cadena según el valor de genre.</p>
<ul>
<li><strong>Iteración:</strong></li>
</ul>
<p>while:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">while</span> (current) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (current<span style="color:#f92672">-&gt;</span>id <span style="color:#f92672">==</span> bookID) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> current;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    current <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>En findBookById, recorre la lista de libros.
for:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> memberFound<span style="color:#f92672">-&gt;</span>issued_count; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (memberFound<span style="color:#f92672">-&gt;</span>issued_books[i] <span style="color:#f92672">==</span> bookID) {
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>En returnBook, busca un libro en la lista de prestados.</p>
<ul>
<li><strong>Recursión:</strong></li>
</ul>
<p>En <strong>displayBooksRecursive</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">displayBooksRecursive</span>(<span style="color:#66d9ef">book_t</span> <span style="color:#f92672">*</span>library) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>library) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(...);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">displayBooksRecursive</span>(library<span style="color:#f92672">-&gt;</span>next);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Recorre la lista de libros recursivamente.</p>
<h2 id="8-subprogramas">8. Subprogramas</h2>
<p>Los subprogramas son funciones que encapsulan tareas específicas. En el código:</p>
<ul>
<li><strong>Funciones:</strong></li>
</ul>
<p>addBook: Agrega un libro a la lista.
findBookById: Busca un libro por ID.
displayBooksRecursive: Muestra libros recursivamente.
issueBook: Presta un libro a un miembro.
freeLibrary: Libera memoria de la lista de libros.
main: Punto de entrada, controla el flujo del programa.</p>
<ul>
<li><strong>Características:</strong></li>
</ul>
<p>Parámetros: Por valor (int bookID) o puntero (book_t <em><em>library).
Retorno: const char</em> en genreToString, book_t</em> en findBookById, void en addBook.
Modularidad: Cada función realiza una tarea específica, como agregar, prestar o liberar.</p>
<h2 id="9-tipos-de-datos">9. Tipos de datos</h2>
<p>El código utiliza varios tipos de datos:</p>
<p><strong>Primitivos:</strong></p>
<ul>
<li>int: id, publication_year, quantity, bookCount.</li>
<li>char: Arreglos como title[100], author[100].</li>
<li>FILE*: Para manejar archivos en saveLibraryToFile.</li>
</ul>
<h4 id="definidos-por-el-usuario">Definidos por el usuario:</h4>
<ul>
<li><strong>Enumeración:</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">enum</span> { FICTION, NON_FICTION, ... } <span style="color:#66d9ef">genre_t</span>;
</span></span></code></pre></div><p>Define géneros de libros.</p>
<ul>
<li><strong>Estructuras:</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _book {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> id;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> title[<span style="color:#ae81ff">100</span>];
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> _book <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">book_t</span>;
</span></span></code></pre></div><p>Representa un libro con un enlace al siguiente.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _member {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> id;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> name[<span style="color:#ae81ff">100</span>];
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> _member <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">member_t</span>;
</span></span></code></pre></div><p>Representa un miembro con un enlace al siguiente.</p>
<ul>
<li><strong>Punteros:</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">book_t</span><span style="color:#f92672">*</span>, <span style="color:#66d9ef">member_t</span><span style="color:#f92672">*:</span> Para listas enlazadas.
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span><span style="color:#f92672">*:</span> issued_books en <span style="color:#66d9ef">member_t</span>.
</span></span><span style="display:flex;"><span>Punteros dobles: <span style="color:#66d9ef">book_t</span> <span style="color:#f92672">**</span>library, <span style="color:#66d9ef">member_t</span> <span style="color:#f92672">**</span>members para modificar listas.
</span></span></code></pre></div><ul>
<li><strong>Arreglos:</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">char</span> title[<span style="color:#ae81ff">100</span>], <span style="color:#66d9ef">char</span> author[<span style="color:#ae81ff">100</span>].
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>issued_books: <span style="color:#75715e">//Arreglo dinámico para IDs de libros prestados.
</span></span></span></code></pre></div><h1 id="memory_managementc">memory_management.c</h1>
<h2 id="1-nombres-1">1. Nombres</h2>
<p>Los nombres son identificadores para variables, funciones, estructuras, etc. Aquí están los nombres únicos de este código:</p>
<p><strong>Variables:</strong></p>
<ul>
<li><strong>Globales:</strong> heap_allocations, heap_deallocations, stack_allocations, stack_deallocations (contadores para seguimiento de memoria).</li>
<li><strong>Global con puntero:</strong> heap_memory_records (puntero a una lista de registros de memoria).
Locales: record (en addMemoryRecord), current (en removeMemoryRecord y displayMemoryUsage), to_free (en removeMemoryRecord).</li>
</ul>
<p><strong>Funciones:</strong></p>
<ul>
<li>addMemoryRecord, removeMemoryRecord, displayMemoryUsage, incrementHeapAllocations, incrementHeapDeallocations, incrementStackAllocations, incrementStackDeallocations.</li>
</ul>
<p><strong>Estructuras:</strong></p>
<ul>
<li>MemoryRecord (definida con typedef).</li>
</ul>
<p><strong>Constantes:</strong></p>
<ul>
<li>MEMORY_MANAGEMENT_DISPLAY (macro condicional para controlar la salida de depuración).</li>
</ul>
<h2 id="2-marcos-de-activación">2. Marcos de activación</h2>
<p>Los marcos de activación son áreas en el stack para las variables locales y parámetros de una función. Elementos únicos:</p>
<p><strong>En addMemoryRecord:</strong></p>
<ul>
<li><strong>Parámetros:</strong> pointer (tipo void*), size (tipo size_t).</li>
<li><strong>Variable local:</strong> record (tipo MemoryRecord*).</li>
<li>El marco de activación almacena estas variables y se libera al retornar.</li>
</ul>
<p><strong>En removeMemoryRecord:</strong></p>
<ul>
<li><strong>Parámetro:</strong> pointer (tipo void*).</li>
<li><strong>Variables locales:</strong> current (tipo MemoryRecord**), to_free (tipo MemoryRecord*).</li>
</ul>
<p><strong>En displayMemoryUsage:</strong></p>
<ul>
<li><strong>Variable local:</strong> current (tipo MemoryRecord*).</li>
</ul>
<h2 id="3-bloques-de-alcance-1">3. Bloques de alcance</h2>
<p>Los bloques de alcance determinan la visibilidad y vida útil de los nombres. Elementos únicos:</p>
<p><strong>Alcance global:</strong></p>
<ul>
<li><strong>Variables:</strong> heap_allocations, heap_deallocations, stack_allocations, stack_deallocations, heap_memory_records.
Estas variables son accesibles en todo el programa y persisten durante toda la ejecución.</li>
</ul>
<p><strong>Alcance de función:</strong></p>
<ul>
<li><strong>En addMemoryRecord:</strong> record solo es visible dentro de la función.</li>
<li><strong>En removeMemoryRecord:</strong> current y to_free son locales a la función.</li>
<li><strong>En displayMemoryUsage:</strong> current es local.</li>
</ul>
<p>Alcance condicional (por macro):</p>
<p>Las funciones incrementHeapAllocations y incrementHeapDeallocations tienen bloques condicionales controlados por #if MEMORY_MANAGEMENT_DISPLAY, que afectan la visibilidad de las llamadas a printf dentro de esos bloques.</p>
<h2 id="4-administración-de-memoria-1">4. Administración de memoria</h2>
<p>Este código se centra en la gestión de memoria, con elementos únicos:</p>
<ul>
<li><strong>Segmento de datos:</strong></li>
</ul>
<p>Variables globales inicializadas: heap_allocations, heap_deallocations, stack_allocations, stack_deallocations (inicializadas en 0).</p>
<ul>
<li>
<p><strong>Heap:</strong></p>
<ul>
<li><strong>Asignación dinámica:</strong></li>
</ul>
</li>
</ul>
<p>En addMemoryRecord: record = (MemoryRecord *)malloc(sizeof(MemoryRecord)) asigna memoria para un nuevo registro.</p>
<ul>
<li><strong>Liberación:</strong></li>
</ul>
<p>En removeMemoryRecord: free(to_free) libera un nodo de la lista de registros.</p>
<ul>
<li><strong>Lista enlazada para seguimiento:</strong></li>
</ul>
<p>heap_memory_records es una lista enlazada que registra punteros y tamaños de memoria asignada en el heap.
addMemoryRecord agrega un nodo a esta lista.
removeMemoryRecord elimina un nodo específico.</p>
<p>Seguimiento de memoria:</p>
<p>Contadores globales (heap_allocations, heap_deallocations) rastrean el número de asignaciones y liberaciones en el heap.
Contadores stack_allocations y stack_deallocations (aunque no se usan explícitamente en el código previo para asignaciones automáticas).</p>
<p>Condicionalidad:</p>
<p>La macro MEMORY_MANAGEMENT_DISPLAY controla si se muestran mensajes de depuración (printf) sobre asignaciones y liberaciones.</p>
<h2 id="5-expresiones-1">5. Expresiones</h2>
<p><strong>Expresiones únicas en este código:</strong></p>
<p><strong>Asignación:</strong></p>
<ul>
<li>record-&gt;pointer = pointer y record-&gt;size = size en addMemoryRecord.
heap_memory_records = record en addMemoryRecord.</li>
</ul>
<p><strong>Punteros y desreferenciación:</strong></p>
<ul>
<li>(*current)-&gt;pointer == pointer en removeMemoryRecord (compara el puntero almacenado).
current = &amp;(*current)-&gt;next en removeMemoryRecord (avanza al siguiente nodo).</li>
</ul>
<p><strong>Incrementos:</strong></p>
<ul>
<li>heap_allocations++ en incrementHeapAllocations.</li>
<li>heap_deallocations++ en incrementHeapDeallocations.</li>
</ul>
<p><strong>Formato de cadenas:</strong></p>
<ul>
<li>En displayMemoryUsage: printf(&quot;| 0x%-14p | %-27zu |\n&rdquo;, current-&gt;pointer, current-&gt;size) para mostrar punteros y tamaños.</li>
</ul>
<h2 id="6-comandos-1">6. Comandos</h2>
<p><strong>Comandos únicos (instrucciones ejecutables):</strong></p>
<ul>
<li>
<p><strong>Asignaciones:</strong></p>
<ul>
<li><strong>record-&gt;next = heap_memory_records</strong> en addMemoryRecord.</li>
<li><em><strong>current = (<em>current)-&gt;next</em></strong></em> en removeMemoryRecord.</li>
</ul>
</li>
<li>
<p><strong>Entrada/salida:</strong></p>
<ul>
<li><strong>En displayMemoryUsage:</strong></li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;|   Asignaciones: %-28d |</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, heap_allocations);
</span></span></code></pre></div><p>Muestra contadores de memoria.</p>
<ul>
<li><strong>En incrementHeapAllocations:</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Memoria asignada en el heap: Puntero=0x%p, Tamano=%zu bytes</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, pointer, size);
</span></span></code></pre></div><ul>
<li>
<p><strong>Liberación de memoria:</strong></p>
<ul>
<li><strong>free(to_free)</strong> en removeMemoryRecord.</li>
</ul>
</li>
</ul>
<h2 id="7-control-de-secuencia">7. Control de secuencia</h2>
<p><strong>Elementos únicos de control de secuencia:</strong></p>
<ul>
<li>
<p><strong>Selección:</strong></p>
<ul>
<li><strong>if:</strong></li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> ((<span style="color:#f92672">*</span>current)<span style="color:#f92672">-&gt;</span>pointer <span style="color:#f92672">==</span> pointer) {
</span></span><span style="display:flex;"><span>    MemoryRecord <span style="color:#f92672">*</span>to_free <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>current;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>current <span style="color:#f92672">=</span> (<span style="color:#f92672">*</span>current)<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free</span>(to_free);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>En removeMemoryRecord, verifica si el puntero coincide para eliminar el registro.</p>
<ul>
<li>
<p><strong>Iteración:</strong></p>
<ul>
<li><strong>while:</strong></li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">while</span> (<span style="color:#f92672">*</span>current) {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    current <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>(<span style="color:#f92672">*</span>current)<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>En removeMemoryRecord, recorre la lista para encontrar el puntero.
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">cwhile</span> (current) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;| 0x%-14p | %-27zu |</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, current<span style="color:#f92672">-&gt;</span>pointer, current<span style="color:#f92672">-&gt;</span>size);
</span></span><span style="display:flex;"><span>    current <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>En displayMemoryUsage, muestra todos los registros de memoria.</p>
<ul>
<li>
<p><strong>Recursión:</strong></p>
<ul>
<li>No hay recursión explícita en este código (a diferencia del código anterior con displayBooksRecursive).</li>
</ul>
</li>
<li>
<p><strong>Directivas de preprocesador:</strong></p>
<ul>
<li>#if MEMORY_MANAGEMENT_DISPLAY controla condicionalmente la ejecución de printf en displayMemoryUsage, incrementHeapAllocations y incrementHeapDeallocations.</li>
</ul>
</li>
</ul>
<h2 id="8-subprogramas-1">8. Subprogramas</h2>
<ul>
<li>
<p><strong>Subprogramas (funciones) únicos en este código:</strong></p>
<p><strong>addMemoryRecord(void <em>pointer, size_t size):</em></strong></p>
<ul>
<li>Crea un nuevo nodo MemoryRecord y lo agrega a la lista heap_memory_records.</li>
</ul>
<p><strong>removeMemoryRecord(void <em>pointer):</em></strong></p>
<ul>
<li>Busca y elimina un nodo de la lista heap_memory_records basado en el puntero.</li>
</ul>
<p><strong>displayMemoryUsage():</strong></p>
<ul>
<li>Muestra estadísticas de memoria (contadores y detalles de heap).</li>
</ul>
<p><strong>incrementHeapAllocations(void <em>pointer, size_t size):</em></strong></p>
<ul>
<li>Incrementa el contador de asignaciones y registra el puntero/tamaño.</li>
</ul>
<p><strong>incrementHeapDeallocations(void <em>pointer):</em></strong></p>
<ul>
<li>Incrementa el contador de liberaciones y elimina el registro.</li>
</ul>
<p><strong>incrementStackAllocations() y incrementStackDeallocations():</strong></p>
<ul>
<li>Incrementan contadores para el stack (aunque no se usan en el código previo).</li>
</ul>
</li>
</ul>
<h2 id="9-tipos-de-datos-1">9. Tipos de datos</h2>
<ul>
<li>
<p><strong>Tipos de datos únicos:</strong></p>
<ul>
<li>
<p><strong>Primitivos:</strong></p>
<ul>
<li><strong>int:</strong> heap_allocations, heap_deallocations, stack_allocations, stack_deallocations.</li>
<li><strong>size_t:</strong> Para el tamaño de memoria en addMemoryRecord e incrementHeapAllocations.</li>
<li><em><em>void</em>:</em>* Para punteros genéricos en pointer (en addMemoryRecord, removeMemoryRecord, etc.).</li>
</ul>
</li>
<li>
<p><strong>Definidos por el usuario:</strong></p>
<ul>
<li><strong>Estructura:</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> MemoryRecord {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>pointer;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">size_t</span> size;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> MemoryRecord <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>} MemoryRecord;
</span></span></code></pre></div><p>Representa un registro de memoria asignada en el heap.</p>
<ul>
<li>
<p><strong>Punteros:</strong></p>
<ul>
<li><em><em>MemoryRecord</em>:</em>* heap_memory_records, record, current.</li>
<li><strong>MemoryRecord</strong>:** current en removeMemoryRecord (puntero doble para modificar la lista).</li>
<li><em><em>void</em>:</em>* Para almacenar punteros genéricos en MemoryRecord.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="conclusion">conclusion</h1>
<p>En mi opinión, el programa en C para la gestión de una biblioteca es un excelente ejemplo de cómo los fundamentos de programación estructurada pueden aplicarse para crear un sistema funcional y eficiente. La claridad en el uso de nombres, la organización modular de los subprogramas y el manejo cuidadoso de la memoria dinámica reflejan un diseño bien pensado.</p>
<h1 id="referencias">Referencias</h1>
<p><a href="https://github.com/papux100/Portafolio">repositorio Papux100</a>.</p>
<p><a href="https://papux100.github.io/Portafolio/blog">pagina Papux100</a>.</p>
<ol>
<li>U2 - Programming Paradigms.pdf. (n.d.). Google Docs. <a href="https://drive.google.com/file/d/1Ts1HTPs-ho9X-wjSw81eRFSJpDrPnJ5w/view">https://drive.google.com/file/d/1Ts1HTPs-ho9X-wjSw81eRFSJpDrPnJ5w/view</a></li>
</ol>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white white-70 dn dib-ns pv2 ph3 no-underline" href="http://localhost:1313/Portafolio/" >
    &copy;  My New Hugo Site 2025 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
